# fnv-basics

My threat model is interested in the general problem of taking a fixed hash `H` and solving for unknown `M` such that `FNV(M) == H`, where FNV is a family of hash functions with two flavors -- FNV1 and FNV1a.

They are, fundamentally, parameterized as follows:

```py
def fnv1_core(data, basis, prime, num_bits):
    # Start with hash as basis
    result = basis

    # Mix each byte of data into the hash
    for b in data:
        # Multiply by prime
        result *= prime
        # Xor by current byte of data
        result ^= ord(b)
        # Mask to desired bitwidth
        result &= ((1 << num_bits) - 1)

    # Return calculated hash
    return result

def fnv1a_core(data, basis, prime, num_bits):
    # Start with hash as basis
    result = basis

    # Mix each byte of data into the hash
    for b in data:
        # Xor by current byte of data
        result ^= ord(b)
        # Multiply by prime
        result *= prime
        # Mask to desired bitwidth
        result &= ((1 << num_bits) - 1)

    # Return calculated hash
    return result
```

Traditionally, the value of `basis` is fixed via an algorithm for finding primes with nice properties.

This is relatively unimportant, except to note that the following values are used for hash-sizes that I might care about:

```py
FNV_PRIME_32  = 0x01000193
FNV_PRIME_64  = 0x00000000100000001B3
```

And similarly traditionally, `basis` is generated by use of `fnv1_core` with basis=0 (called by literature "fnv0") on the string:

`chongo <Landon Curt Noll> /\../\`

Thus, we have traditionally:
```py
FNV_BASIS_32 = fnv1_core('chongo <Landon Curt Noll> /\\../\\', 0, FNV_PRIME_32, 32)
assert(FNV_BASIS_32 == 0x811C9DC5)

FNV_BASIS_64 = fnv1_core('chongo <Landon Curt Noll> /\\../\\', 0, FNV_PRIME_64, 64)
assert(FNV_BASIS_64 == 0xCBF29CE484222325)
```

And thus arive at the following definitions for the relevant hash functions:

```py
fnv1_32  = lambda data: fnv1_core(data, FNV_BASIS_32, FNV_PRIME_32, 32)
fnv1_64  = lambda data: fnv1_core(data, FNV_BASIS_64, FNV_PRIME_64, 64)

fnv1a_32 = lambda data: fnv1a_core(data, FNV_BASIS_32, FNV_PRIME_32, 32)
fnv1a_64 = lambda data: fnv1a_core(data, FNV_BASIS_64, FNV_PRIME_64, 64)
```

However, I note to the generic reader that my interest in FNV primarily arises from its usage in Pokemon games on the Nintendo Switch.

Gamefreak uses FNV in the context of flatbuffers. This has resulted in them using the flatbuffers implementation, for which a google engineer (possibly mistakenly?) [calculated a non-standard basis](https://chromium.googlesource.com/external/github.com/google/flatbuffers/+/v1.1.0/include/flatbuffers/hash.h#40) for FNV-64 (they use the standard basis for FNV-32).

For reference, this results in the following (acronymizing as "GF", which conveniently refers both to gamefreak and google flatbuffers):

```py
FNV_BASIS_64_GF = 0xCBF29CE484222645

fnv1_64_gf = lambda data: fnv1_core(data, FNV_BASIS_64_GF, FNV_PRIME_64, 64)
fnv1a_64_gf = lambda data: fnv1a_core(data, FNV_BASIS_64_GF, FNV_PRIME_64, 64)
```